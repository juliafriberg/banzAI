///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>

/**
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

  //////////////////////////////////////////////////////////////////////
  // exported functions, classes and interfaces/types

  /**
   * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter.
   * @param interpretations List of possible interpretations.
   * @param currentState The current state of the world.
   * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
   */
  export function plan(interpretations: Interpreter.InterpretationResult[], currentState: WorldState): PlannerResult[] {
    var errors: Error[] = [];
    var plans: PlannerResult[] = [];
    interpretations.forEach((interpretation) => {
      try {
        var result: PlannerResult = <PlannerResult>interpretation;
        result.plan = planInterpretation(result.interpretation, currentState);
        if (result.plan.length == 0) {
          result.plan.push("That is already true!");
        }
        plans.push(result);
      } catch (err) {
        errors.push(err);
      }
    });
    if (plans.length) {
      return plans;
    } else {
      // only throw the first error found
      throw errors[0];
    }
  }

  export interface PlannerResult extends Interpreter.InterpretationResult {
    plan: string[];
  }

  export function stringify(result: PlannerResult): string {
    return result.plan.join(", ");
  }

  //////////////////////////////////////////////////////////////////////
  // private functions

  /**
   * The core planner function. The code here is just a template;
   * you should rewrite this function entirely. In this template,
   * the code produces a dummy plan which is not connected to the
   * argument `interpretation`, but your version of the function
   * should be such that the resulting plan depends on
   * `interpretation`.
   *
   *
   * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
   * @param state The current world state.
   * @returns Basically, a plan is a
   * stack of strings, which are either system utterances that
   * explain what the robot is doing (e.g. "Moving left") or actual
   * actions for the robot to perform, encoded as "l", "r", "p", or
   * "d". The code shows how to build a plan. Each step of the plan can
   * be added using the `push` method.
   */
  function planInterpretation(interpretation: Interpreter.DNFFormula, state: WorldState): string[] {
    // This function returns a dummy plan involving a random stack

    /*
    1. graph with starting node
    2. outgoingEdges gives each possible move (take or drop), making sure the
      laws are followed. Cost is left/right moves for arm + 1
    3. Nodes have the complete world state.
    4. goal function compares the interpretation to the node state
    5. heuristics depend on the interpetation. coming soon

    6. loop through states in result in order, making the moves.

    ["Picking up *objet*", "r" "r" "r" "p"]
    */

    class StateNode {
      constructor(
        public state: WorldState
        ) { }

      compareTo(other: StateNode): number {
        for (let s in this.state.stacks) {
          if (this.state.stacks[s].toString() !== other.state.stacks[s].toString())
            return -1;
        }
        return 0;
      }

      toString(): string {
        return state.toString();
      }
    }


    class StateGraph implements Graph<StateNode> {
      outgoingEdges(node: StateNode): Edge<StateNode>[] {
        var edges: Edge<StateNode>[] = [];
        if (node.state.holding) {
          for (var s = 0; s < node.state.stacks.length; s++) {
            var stackLength = node.state.stacks[s].length;
            if (stackLength) {
              var last = node.state.stacks[s][stackLength - 1];
              if (isAllowed(node.state.holding, last)) {
                var newState = cloneState(node.state);
                newState.stacks[s].push(node.state.holding);
                newState.holding = null;
                newState.arm = s;
                var nextNode = new StateNode(newState);
                edges.push({
                  from: node,
                  to: nextNode,
                  cost: Math.abs(node.state.arm - s) + 1
                });
              }
            } else {
              var newState = cloneState(node.state);
              newState.stacks[s].push(node.state.holding);
              newState.holding = null;
              newState.arm = s;
              var nextNode = new StateNode(newState);
              edges.push({
                from: node,
                to: nextNode,
                cost: Math.abs(node.state.arm - s) + 1
              });
            }
          }
        } else {
          for (var s = 0; s < node.state.stacks.length; s++) {
            var stackLength = node.state.stacks[s].length;
            if (stackLength) {
              var newState = cloneState(node.state);
              var taken = newState.stacks[s].pop()
              newState.holding = taken;
              newState.arm = s;
              var nextNode = new StateNode(newState);
              edges.push({
                from: node,
                to: nextNode,
                cost: Math.abs(node.state.arm - s) + 1
              });
            }
          }
        }

        return edges;
      }

      compareNodes(a: StateNode, b: StateNode): number {
        return a.compareTo(b);
      }
    }

    function cloneState(state: WorldState): WorldState {
      return JSON.parse(JSON.stringify(state));

    }

    function isAllowed(over: string, under: string): boolean {
      var overObj = state.objects[over];
      var underObj = state.objects[under];

      if (overObj.size === "large" && underObj.size === "small") return false;
      if (underObj.form === "ball") return false;
      if (overObj.form === "ball" && underObj.form !== "box") return false;
      if (underObj.form === "box" && overObj.size === underObj.size
        && contains(["plank", "pyramid", "box"], overObj.form)) return false;
      if (overObj.form === "box" && overObj.size === "small" && underObj.size === "small"
        && contains(["brick", "pyramid"], underObj.form)) return false;
      if (underObj.form === "pyramid" && overObj.form === "box" && underObj.size === "large"
        && overObj.size === "large") return false;


      return true;
    }

    /**
    * Calculates the specific position of an object in the world.
    * @param object The object to find the position of.
    * @returns Two numbers; which stack the object is in, and where in the stack it is.
    */
    function getPosition(object: string, state: WorldState): number[] {
      var stacknumber: number = -1;
      var objectnumber: number = -1;
      for (var j = 0; j < state.stacks.length; j++) {
        objectnumber = state.stacks[j].indexOf(object);
        if (objectnumber > -1) {
          stacknumber = j;
          break;
        }
      }
      return [stacknumber, objectnumber];
    }

    function contains<T>(arr: T[], elem: T) {
      return arr.indexOf(elem) > -1;
    }

    // ojojoj
    function isGoal(node: StateNode): boolean {
      for (let c in interpretation) {
        var blah : boolean = false;
        for (let l in interpretation[c]) {
          var literal: Interpreter.Literal = interpretation[c][l];
          blah = false;
          if (literal.relation === "holding") {
            blah = node.state.holding === literal.args[0];
          } else {
            var pos0: number[] = getPosition(literal.args[0], node.state);
            if (literal.args[1] === "floor") {
              if (literal.relation === "above") {
                blah = true;
              } else if (literal.relation === "ontop") {
                if (pos0[1] === 0) {
                  blah = true;
                }
              }
            } else {
              var pos1: number[] = getPosition(literal.args[1], node.state);
              if(pos0[0] === -1 || pos0[1] === -1 || pos1[0] === -1 || pos1[1] === -1) {
                blah = false;

              } else {
                switch (literal.relation) {
                  case "ontop":
                  case "inside":
                    blah = (pos0[0] === pos1[0] && pos0[1] - pos1[1] === 1);
                    break;

                  case "above":
                    blah = (pos0[0] === pos1[0] && pos0[1] - pos1[1] >= 1);
                    break;

                  case "under":
                    blah = (pos0[0] === pos1[0] && pos1[1] - pos0[1] >= 1);
                    break;

                  case "rightof":
                    blah = (pos0[0] - pos1[0] >= 1);
                    break;

                  case "leftof":
                    blah = (pos1[0] - pos0[0] >= 1);
                    break;

                  case "beside":
                    blah = (Math.abs(pos0[0] - pos1[0]) === 1);
                    break;
                }
              }
            }

          }
          // one of the literals in the conjunctive formula was false
          if(!blah) break;
        }
        if (blah)
          return true;
      }
      return false;

    }

    function heuristics(node: StateNode): number {
      var h: number = 0;
      return h;
    }

    var firstNode = new StateNode(state);
    var graph = new StateGraph();
    var plan: string[] = []
    var timeout : number = 60
    var result = aStarSearch(graph, firstNode, isGoal, heuristics, timeout)
    var oldState = state;

    for (var node = 1; node < result.path.length; node++) {
      var nextState = result.path[node].state
      if (nextState.holding) {
        var stackNum = getPosition(nextState.holding, oldState)[0];
        var dir: string = (stackNum < oldState.arm) ? "l" : "r";
        plan.push("Taking " + state.objects[nextState.holding].form)
        for (var i = 0; i < Math.abs(stackNum - oldState.arm); i++) {
          plan.push(dir)
        }
        plan.push("p")

      } else {
        var stackNum = getPosition(oldState.holding, nextState)[0];
        console.log("Stacknum: " + stackNum)
        console.log("Oldstate.arm: " + oldState.arm)
        var dir: string = (stackNum < oldState.arm) ? "l" : "r";
        plan.push("Putting down "+ state.objects[oldState.holding].form)
        for (var i = 0; i < Math.abs(stackNum - oldState.arm); i++) {
          plan.push(dir)
        }
        plan.push("d")
      }
      oldState = nextState;
    }
    return plan;
  }

}
